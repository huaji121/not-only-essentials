// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { Vector2Utils, Vector3Utils, VectorXZUtils } from './coreHelpers.js';
/**
 * Vector3 wrapper class which can be used as a Vector3 for APIs on \@minecraft/server which require a Vector,
 * but also contain additional helper methods. This is an alternative to using the core Vector 3 utility
 * methods directly, for those who prefer a more object-oriented approach. This version of the class is mutable
 * and changes state inline.
 *
 * For an immutable version of the build, use ImmutableVector3Builder.
 *
 * @public
 */
export class Vector3Builder {
    x;
    y;
    z;
    constructor(first, second, z) {
        if (typeof first === 'object') {
            this.x = first.x;
            this.y = first.y;
            this.z = first.z;
        }
        else if (typeof first === 'string') {
            const parsed = Vector3Utils.fromString(first, second ?? ',');
            if (!parsed) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                return;
            }
            this.x = parsed.x;
            this.y = parsed.y;
            this.z = parsed.z;
        }
        else {
            this.x = first;
            this.y = second ?? 0;
            this.z = z ?? 0;
        }
    }
    /**
     * Assigns the values of the passed in vector to this vector. Returns itself.
     */
    assign(vec) {
        this.x = vec.x;
        this.y = vec.y;
        this.z = vec.z;
        return this;
    }
    /**
     * equals
     *
     * Check the equality of two vectors
     */
    equals(v) {
        return Vector3Utils.equals(this, v);
    }
    /**
     * add
     *
     * Adds the vector v to this, returning itself.
     */
    add(v) {
        return this.assign(Vector3Utils.add(this, v));
    }
    /**
     * subtract
     *
     * Subtracts the vector v from this, returning itself.
     */
    subtract(v) {
        return this.assign(Vector3Utils.subtract(this, v));
    }
    /** scale
     *
     * Scales this by the passed in value, returning itself.
     */
    scale(val) {
        return this.assign(Vector3Utils.scale(this, val));
    }
    /**
     * dot
     *
     * Computes the dot product of this and the passed in vector.
     */
    dot(vec) {
        return Vector3Utils.dot(this, vec);
    }
    /**
     * cross
     *
     * Computes the cross product of this and the passed in vector, returning itself.
     */
    cross(vec) {
        return this.assign(Vector3Utils.cross(this, vec));
    }
    /**
     * magnitude
     *
     * The magnitude of the vector
     */
    magnitude() {
        return Vector3Utils.magnitude(this);
    }
    /**
     * distance
     *
     * Calculate the distance between two vectors
     */
    distance(vec) {
        return Vector3Utils.distance(this, vec);
    }
    /**
     * normalize
     *
     * Normalizes this vector, returning itself.
     */
    normalize() {
        return this.assign(Vector3Utils.normalize(this));
    }
    /**
     * floor
     *
     * Floor the components of a vector to produce a new vector
     */
    floor() {
        return this.assign(Vector3Utils.floor(this));
    }
    /**
     * ceil
     *
     * Ceil the components of a vector to produce a new vector
     */
    ceil() {
        return this.assign(Vector3Utils.ceil(this));
    }
    /**
     * min
     *
     * Min the components of two vectors to produce a new vector
     */
    min(vec) {
        return this.assign(Vector3Utils.min(this, vec));
    }
    /**
     * max
     *
     * Max the components of two vectors to produce a new vector
     */
    max(vec) {
        return this.assign(Vector3Utils.max(this, vec));
    }
    /**
     * toString
     *
     * Create a string representation of a vector
     */
    toString(options) {
        return Vector3Utils.toString(this, options);
    }
    /**
     * clamp
     *
     * Clamps the components of a vector to limits to produce a new vector
     */
    clamp(limits) {
        return this.assign(Vector3Utils.clamp(this, limits));
    }
    /**
     * lerp
     *
     * Constructs a new vector using linear interpolation on each component from two vectors.
     */
    lerp(vec, t) {
        return this.assign(Vector3Utils.lerp(this, vec, t));
    }
    /**
     * slerp
     *
     * Constructs a new vector using spherical linear interpolation on each component from two vectors.
     */
    slerp(vec, t) {
        return this.assign(Vector3Utils.slerp(this, vec, t));
    }
    /**
     * multiply
     *
     * Element-wise multiplication of two vectors together.
     * Not to be confused with {@link Vector3Builder.dot} product or {@link Vector3Builder.cross} product
     */
    multiply(vec) {
        return this.assign(Vector3Utils.multiply(this, vec));
    }
    /**
     * rotateX
     *
     * Rotates the vector around the x axis counterclockwise (left hand rule)
     * @param a - Angle in radians
     */
    rotateX(a) {
        return this.assign(Vector3Utils.rotateX(this, a));
    }
    /**
     * rotateY
     *
     * Rotates the vector around the y axis counterclockwise (left hand rule)
     * @param a - Angle in radians
     */
    rotateY(a) {
        return this.assign(Vector3Utils.rotateY(this, a));
    }
    /**
     * rotateZ
     *
     * Rotates the vector around the z axis counterclockwise (left hand rule)
     * @param a - Angle in radians
     */
    rotateZ(a) {
        return this.assign(Vector3Utils.rotateZ(this, a));
    }
}
/**
 * Vector2 wrapper class which can be used as a Vector2 for APIs on \@minecraft/server which require a Vector2.
 * @public
 */
export class Vector2Builder {
    x;
    y;
    constructor(first, second) {
        if (typeof first === 'object') {
            this.x = first.x;
            this.y = first.y;
        }
        else if (typeof first === 'string') {
            const parsed = Vector2Utils.fromString(first, second ?? ',');
            if (!parsed) {
                this.x = 0;
                this.y = 0;
                return;
            }
            this.x = parsed.x;
            this.y = parsed.y;
        }
        else {
            this.x = first;
            this.y = second ?? 0;
        }
    }
    toString(options) {
        return Vector2Utils.toString(this, options);
    }
    /**
     * Assigns the values of the passed in vector to this vector. Returns itself.
     */
    assign(vec) {
        this.x = vec.x;
        this.y = vec.y;
        return this;
    }
    /**
     * equals
     *
     * Check the equality of two vectors
     */
    equals(v) {
        return Vector2Utils.equals(this, v);
    }
    /**
     * add
     *
     * Adds the vector v to this, returning itself.
     */
    add(v) {
        return this.assign(Vector2Utils.add(this, v));
    }
    /**
     * subtract
     *
     * Subtracts the vector v from this, returning itself.
     */
    subtract(v) {
        return this.assign(Vector2Utils.subtract(this, v));
    }
    /** scale
     *
     * Scales this by the passed in value, returning itself.
     */
    scale(val) {
        return this.assign(Vector2Utils.scale(this, val));
    }
    /**
     * dot
     *
     * Computes the dot product of this and the passed in vector.
     */
    dot(vec) {
        return Vector2Utils.dot(this, vec);
    }
    /**
     * magnitude
     *
     * The magnitude of the vector
     */
    magnitude() {
        return Vector2Utils.magnitude(this);
    }
    /**
     * distance
     *
     * Calculate the distance between two vectors
     */
    distance(vec) {
        return Vector2Utils.distance(this, vec);
    }
    /**
     * normalize
     *
     * Normalizes this vector, returning itself.
     */
    normalize() {
        return this.assign(Vector2Utils.normalize(this));
    }
    /**
     * floor
     *
     * Floor the components of a vector to produce a new vector
     */
    floor() {
        return this.assign(Vector2Utils.floor(this));
    }
    /**
     * clamp
     *
     * Clamps the components of a vector to limits to produce a new vector
     */
    clamp(limits) {
        return this.assign(Vector2Utils.clamp(this, limits));
    }
    /**
     * lerp
     *
     * Constructs a new vector using linear interpolation on each component from two vectors.
     */
    lerp(vec, t) {
        return this.assign(Vector2Utils.lerp(this, vec, t));
    }
    /**
     * slerp
     *
     * Constructs a new vector using spherical linear interpolation on each component from two vectors.
     */
    slerp(vec, t) {
        return this.assign(Vector2Utils.slerp(this, vec, t));
    }
    /**
     * multiply
     *
     * Element-wise multiplication of two vectors together.
     * Not to be confused with {@link Vector2Builder.dot} product
     */
    multiply(vec) {
        return this.assign(Vector2Utils.multiply(this, vec));
    }
}
/**
 * VectorXZ wrapper class which can be used as a VectorXZ for APIs on \@minecraft/server which require a VectorXZ.
 * @public
 */
export class VectorXZBuilder {
    x;
    z;
    constructor(first, second) {
        if (typeof first === 'object') {
            this.x = first.x;
            this.z = first.z;
        }
        else if (typeof first === 'string') {
            const parsed = VectorXZUtils.fromString(first, second ?? ',');
            if (!parsed) {
                this.x = 0;
                this.z = 0;
                return;
            }
            this.x = parsed.x;
            this.z = parsed.z;
        }
        else {
            this.x = first;
            this.z = second ?? 0;
        }
    }
    toString(options) {
        return VectorXZUtils.toString(this, options);
    }
    /**
     * Assigns the values of the passed in vector to this vector. Returns itself.
     */
    assign(vec) {
        this.x = vec.x;
        this.z = vec.z;
        return this;
    }
    /**
     * equals
     *
     * Check the equality of two vectors
     */
    equals(v) {
        return VectorXZUtils.equals(this, v);
    }
    /**
     * add
     *
     * Adds the vector v to this, returning itself.
     */
    add(v) {
        return this.assign(VectorXZUtils.add(this, v));
    }
    /**
     * subtract
     *
     * Subtracts the vector v from this, returning itself.
     */
    subtract(v) {
        return this.assign(VectorXZUtils.subtract(this, v));
    }
    /** scale
     *
     * Scales this by the passed in value, returning itself.
     */
    scale(val) {
        return this.assign(VectorXZUtils.scale(this, val));
    }
    /**
     * dot
     *
     * Computes the dot product of this and the passed in vector.
     */
    dot(vec) {
        return VectorXZUtils.dot(this, vec);
    }
    /**
     * magnitude
     *
     * The magnitude of the vector
     */
    magnitude() {
        return VectorXZUtils.magnitude(this);
    }
    /**
     * distance
     *
     * Calculate the distance between two vectors
     */
    distance(vec) {
        return VectorXZUtils.distance(this, vec);
    }
    /**
     * normalize
     *
     * Normalizes this vector, returning itself.
     */
    normalize() {
        return this.assign(VectorXZUtils.normalize(this));
    }
    /**
     * floor
     *
     * Floor the components of a vector to produce a new vector
     */
    floor() {
        return this.assign(VectorXZUtils.floor(this));
    }
    /**
     * clamp
     *
     * Clamps the components of a vector to limits to produce a new vector
     */
    clamp(limits) {
        return this.assign(VectorXZUtils.clamp(this, limits));
    }
    /**
     * lerp
     *
     * Constructs a new vector using linear interpolation on each component from two vectors.
     */
    lerp(vec, t) {
        return this.assign(VectorXZUtils.lerp(this, vec, t));
    }
    /**
     * slerp
     *
     * Constructs a new vector using spherical linear interpolation on each component from two vectors.
     */
    slerp(vec, t) {
        return this.assign(VectorXZUtils.slerp(this, vec, t));
    }
    /**
     * multiply
     *
     * Element-wise multiplication of two vectors together.
     * Not to be confused with {@link VectorXZBuilder.dot} product
     */
    multiply(vec) {
        return this.assign(VectorXZUtils.multiply(this, vec));
    }
}
//# sourceMappingURL=vectorWrapper.js.map